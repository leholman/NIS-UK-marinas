###### Analysis of raw data for UK marinas 
library("dplyr")
library("vegan")
library("reshape")
library("reshape2")
library("ggplot2")
library("stringr")
library("tidyr")
library("RColorBrewer")
library("metacoder")

minreads <- 3
minOTUfreq <- 0.01
items <- NULL


setwd("~/Desktop/AnalysisUKMarinaData/raw.data/")
sedimentID <- read.csv(file="../sedimentdata.csv")

#### Data Cleaning ####

for (file in  files){
  
  rawdat <-read.csv(file=file)
  
  #remove samples that are not to be analysed, these are labelled 'other' in the location metadata
  metadat <- read.csv(file="../locations.csv",sep=",",header=T)
  seddat <- read.csv(file="../sedimentdata.csv",sep=",",header=T)
  rawdat <- rawdat[colnames(rawdat) %in% metadat$RealID[metadat$Type!="other"]]
  
  
  #Seperate controls and samples
  samples <- rawdat[colnames(rawdat) %in% metadat$RealID[metadat$Type=="sample"]]
  controls <- rawdat[colnames(rawdat) %in% metadat$RealID[metadat$Type=="control"]]
  
  
  #Filter 1 - minimum number of reads for any ID
  samples[samples< minreads] <- 0
  samples <- samples[rowSums(samples) > 0,]
  
  #Filter 2 - within samples OTU must appear in more than one sample (this works becuase there is lots of reps per site and sample)
  filtersam <- samples
  filtersam[filtersam>0 ] <- 1
  filtersam <-filtersam[rowSums(filtersam) > 1,]
  samples <- samples[rownames(samples) %in% rownames(filtersam),]
  
  #Filter 3 -Remove any OTU found in the negative control samples
  controlsCONTAM <- controls[rowSums(controls) > 0,]
  samples <- samples[!(rownames(samples) %in% rownames(controlsCONTAM)),]
  
  
  #Now we write out the cleaned data
  newname <- paste("../cleaned/","Cleaned.",file,sep="")
  write.csv(samples,file=newname)
  
}

#### All samples cleaned ####

#### LULU Effects ####


###Now we want to see what effect LULU has on our data, we know it decreases the number of OTUs but lets produce a table contain pre and post LULU OTU number per OTU clusting method

setwd(dir = "../cleaned/")
files <- system2('ls',stdout=TRUE)

OTUcount <- data.frame("File"=rep("NA",length(files)),"OTUcount"=rep("NA",length(files)))
OTUcount$File <- as.character(OTUcount$File)
OTUcount$OTUcount <- as.numeric(OTUcount$OTUcount)
count <- 1
for (file in files){

  samples <- read.csv(file = file,sep=",",header=TRUE)
  runninglength <- length(samples[,1])
  OTUcount[count,]<- c(file,runninglength)
count <- count+1
}

OTUcount <- cbind(OTUcount[grep("lulu",OTUcount$File),],OTUcount[grep("lulu",OTUcount$File,invert=TRUE),2])
colnames(OTUcount)[3] <- "OTUraw"
colnames(OTUcount)[2] <- "OTUlulu"

#Lets plot a little stacked barplot

pdf(file="../figures/LULUeffect.pdf",width=8.95,height=6.3)
OTUcountT <- as.matrix(t(OTUcount[-1]))
par(mfrow=c(1,1))
par(mar=c(6.1,4.1,4.1,2.1))
barplot(as.numeric(OTUcountT[2,]),col="red",ylim=c(0,12000),ylab="Number of OTUs",names.arg = c("COI.0.97","COI.swarm","COI.unoise","18S.0.97","18S.swarm","18S.unoise"),las=2)
par(new=T)
barplot(as.numeric(OTUcountT[1,]), col='skyblue',ylim=c(0,12000),axes = F)
legend("topright",c("Pre-LULU","Post-LULU"),fill=c("red","skyblue"), bty = "n")
dev.off()

 #There is a clear positive effect on LULU on the dataset. Analyses will proceed using LULU 

#### OTU CLustering Effect ####
#Count number of OTUs in dataset
## Alpha diversity estimates as a result of bioinformatics
###Here we are asking the question do we see more or less OTUs generated by different methods
#We may also ask if by truncating at different numbers of minimum reads converges on a estimate???

#This section assumes all input files have the same number of observations in the same order, it will not work otherwise

#First we get the observation names and create a dataframe to store our results in
spark <- read.csv(file=file[1],sep=",",header=TRUE)
spark <- spark[-1]
files <- files[grep("lulu",files)]
OTUcountbymethod <- as.data.frame(matrix(data=NA,nrow=length(files),ncol=length(colnames(spark))))
colnames(OTUcountbymethod) <- substr(colnames(spark),3,10)
#Cheat to rename cols
colnames(OTUcountbymethod)[13:21] <- as.character(seddat$Code)


count <- 1
for (file in  files){

  loopdata <- read.csv(file=file,sep=",",header=TRUE)
  loopdata <-loopdata[-1]
  
  counter <- function(x){
    temp <- x
    temp[temp>0] <- 1
    return(sum(temp))
    rm(temp)
  }
  loopresults <- apply(loopdata,2,counter)
  OTUcountbymethod[count,] <- unname(loopresults)
   count <- count +1
}
    
#This bit is specific to the data structure, we need to wrangle the data into a long form for plots and stats with OTU no as a responce variable 

OTUcountbymethod$Marker <- substr(files,9,9)  
OTUcountbymethod$OTUclust <- files %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)} %>%
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)} %>%
{gsub("[:.:][a-z]*$","",.)} 

OTUcountbymethod <- OTUcountbymethod %>%
gather("code","OTUnum",1:33) 
OTUcountmethod <- OTUcountbymethod
OTUcountbymethod <- dcast(OTUcountbymethod,code+Marker~OTUclust,value.var="OTUnum")

OTUcountbymethod <-  melt(OTUcountbymethod)
OTUcountbymethod <-rename(OTUcountbymethod,c("variable"="OTUclust","value"="OTUnum"))
OTUcountbymethod <- OTUcountbymethod %>%
separate(code, c("site", "cond")) %>%
separate(site, c("site","rep"),sep=2)

cols <- 1:5
OTUcountbymethod[cols] <- lapply(OTUcountbymethod[cols], factor)
OTUcountbymethod$cond2 <- as.character(OTUcountbymethod$cond) 
OTUcountbymethod$cond2[OTUcountbymethod$cond2=="L"] <- "W"
OTUcountbymethod$cond2[OTUcountbymethod$cond2=="N"] <- "W"
OTUcountbymethod$cond2 <- as.factor(OTUcountbymethod$cond2)

#Now the data is in a long format suitable for figures and statistics.

#First lets seperate out the markers and look at the effects of OTU clustering
resultsZ <- OTUcountbymethod[OTUcountbymethod$Marker=="Z",]
resultsL <- OTUcountbymethod[OTUcountbymethod$Marker=="L",]

pdf(file="../figures/OTUclusteringeffect.pdf",width=11,height=8)
palette(brewer.pal(8,"Set1"))
par(mfrow=c(1,2))        
par(mar=c(7.1,4.1,4.1,2.1))
    

boxplot(resultsL$OTUnum~resultsL$OTUclust+resultsL$site+resultsL$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,las=2,ylab="Number of OTUs",main="COI",ylim=c(450,2800))
rect(-10,0,9.48,4000, col=rgb(0.1,0.1,0.1,alpha=0.35),xpd=F,lwd=0)
boxplot(resultsL$OTUnum~resultsL$OTUclust+resultsL$site+resultsL$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,axes=F,add=T,ylim=c(450,2800))
legend("topright",c("0.97","swarm","unoise3"),fill=brewer.pal(3,"Set1"), bty = "n")
text(3,480,col="white",labels="Sediment",cex=0.75)
text(20,480,col="Black",labels="Water",cex=0.75)


boxplot(resultsZ$OTUnum~resultsZ$OTUclust+resultsZ$site+resultsZ$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,las=2,ylab="Number of OTUs",main="18S",ylim=c(-100,2300))
rect(-1000,-1000,9.48,4000, col=rgb(0.1,0.1,0.1,alpha=0.35),xpd=F,lwd=0)
boxplot(resultsZ$OTUnum~resultsZ$OTUclust+resultsZ$site+resultsZ$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,axes=F,add=T,ylim=c(-100,2300))
legend("topright",c("0.97","swarm","unoise3"),fill=brewer.pal(3,"Set1"), bty = "n")
text(3,-50,col="white",labels="Sediment",cex=0.75)
text(20,-50,col="Black",labels="Water",cex=0.75)

dev.off()

#Now we want to look at beta diversity, we are not normlising here either as comparisons are not being made between sites


files <- system2('ls',stdout=TRUE)
files <- files[grep("lulu",files)]
BdivOTUresults <- as.data.frame(matrix(ncol = length(files),nrow=528))
colnames(BdivOTUresults) <- files

count <- 1
for (file in  files){

  loopdata <- read.csv(file=file,sep=",",header=TRUE)
  loopdata <- loopdata[-1]
  
  OTU.count.distance<-as.matrix(vegdist(t(loopdata), method="bray", upper=FALSE, binary=F))
  OTU.count.distance[lower.tri(OTU.count.distance)] <- NA
  
  pairwise <- melt(OTU.count.distance)
  pairwise <- pairwise[!is.na(pairwise$value),]
  pairwise <- pairwise[pairwise$value>0,]
  
  BdivOTUresults[,count] <- pairwise$value
  
  count <- count+1
}  

#Plotting bray-curtis values for each OTU generating method against each other tests community similarity across methods  
pdf(file="../figures/OTUclusting_BC_COI.pdf")
plot(BdivOTUresults[,1:3])
dev.off()
pdf(file="../figures/OTUclusting_BC_18S.pdf")
plot(BdivOTUresults[,4:6])
dev.off()

##Overall it seems that b diversity information is similar regardless of OTU generation used. We dont want to use 0.97 becuase we know it doesnt represent the biological reality, we dont want to use swarm becuase it generates many more OTUs than possible as it isnt able to deal with errors in Illumina data. unoise3 is best as it attempts to recreate biological seqs. 

#Now we can start dealing with variables of interest to our study. 

#### Longmire's or Freezing ####

#First we need to rarefy our data to make sensible comparisons between sites/conditions
#Read in data
Preserv18S <- read.table(file="Cleaned.Zhanlulu.unoise3.csv",row.names = 1,sep=",",header=TRUE)

#Rarefy

rPreserv18S<-
  Preserv18S%>%
  filter(rowSums(.)>0)%>%
  t(.)%>%
  rrarefy(.,min(rowSums(.)))%>%
  t(.)

rPreserv18S <- as.data.frame(rPreserv18S,row.names = row.names(Preserv18S))


rPreserv18SOTU <- data.frame("sample"=names(rPreserv18S),"OTUnum"=unname(apply(rPreserv18S,2,counter)))
#get rid of leading makrer name
rPreserv18SOTU$sample <- rPreserv18SOTU$sample %>%  
  {gsub("^[A-Z]*","",.)} %>%
  {gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
rPreserv18SOTU <- rPreserv18SOTU[-grep("S.[0-9][0-9]",rPreserv18SOTU$sample),]
#Turn names into conds
rPreserv18SOTU <-separate(rPreserv18SOTU,sample,into=c('site','cond'),sep=4)
rPreserv18SOTU$rep <- substr(rPreserv18SOTU$site,3,3)
rPreserv18SOTU$site <- substr(rPreserv18SOTU$site,1,2)
rPreserv18SOTU$site <- as.factor(rPreserv18SOTU$site)
rPreserv18SOTU$rep <- as.factor(rPreserv18SOTU$rep)
rPreserv18SOTU$cond <- as.factor(rPreserv18SOTU$cond)


#Now the same for COI
PreservCOI <- read.table(file="~/Desktop/AnalysisUKMarinaData/cleaned/Cleaned.Leraylulu.unoise3.csv",row.names = 1,sep=",",header=TRUE)

minimumCOI <- min(colSums(PreservCOI))

#Rarefy
rPreservCOI<-
    PreservCOI%>%
    filter(rowSums(.)>0)%>%
    t(.)%>%
    rrarefy(.,min(rowSums(.)))%>%
    t(.)
rPreservCOI <- as.data.frame(rPreservCOI,row.names = row.names(PreservCOI))
rPreservCOIOTU <- data.frame("sample"=names(rPreservCOI),"OTUnum"=unname(apply(rPreservCOI,2,counter)))
#get rid of leading makrer name
  rPreservCOIOTU$sample <- rPreservCOIOTU$sample %>%  
  {gsub("^[A-Z]*","",.)} %>%
  {gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
  rPreservCOIOTU <- rPreservCOIOTU[-grep("S.[0-9][0-9]",rPreservCOIOTU$sample),]
#Turn names into conds
  rPreservCOIOTU <-separate(rPreservCOIOTU,sample,into=c('site',"cond"))
rPreservCOIOTU$rep <- substr(rPreservCOIOTU$site,3,3)
rPreservCOIOTU$site <- strsplit(rPreservCOIOTU$site,"[0-9]")
rPreservCOIOTU$site <- unlist(rPreservCOIOTU$site)
rPreservCOIOTU$site <- as.factor(rPreservCOIOTU$site)
rPreservCOIOTU$rep <- as.factor(rPreservCOIOTU$rep)
rPreservCOIOTU$cond <- as.factor(rPreservCOIOTU$cond)

pdf(file="../figures/Preserv_all.pdf",width=8,height=4)
par(mfrow=c(1,2))
boxplot(rPreserv18SOTU$OTUnum~rPreserv18SOTU$cond+rPreserv18SOTU$site,xlab="Condition-Site",ylab="OTUs",main="18S", col = rep(c("#E69F00","#0072B2"),4),las=2)
boxplot(rPreservCOIOTU$OTUnum~rPreservCOIOTU$cond+rPreservCOIOTU$site,xlab="Condition-Site",ylab="OTUs",main="COI", col = rep(c("#E69F00","#0072B2"),4),las=2)
dev.off()

#Brilliant now lets see how this pattern interacts with taxonomy

#Read in the taxonomy

strict18Staxonomy <- read.table(file="../taxonomy/18S_SILVA_results.txt",sep="\t")
relaxed18Staxonomy <- read.table(file = "../taxonomy/18SMEGAN_met.txt",sep=",")

strictCOItaxonomy <- read.table(file="../taxonomy/COI_MIDORI_results.txt")
relaxedCOItaxonomy <- read.table(file="../taxonomy/COIMEGAN_met.txt",sep=",")

#Now lets subset the data by the taxonomy 

rPreserv18Smet <-rPreserv18S[row.names(rPreserv18S) %in% unique(c(as.character(strict18Staxonomy$V1),as.character(relaxed18Staxonomy$V1))),]
rPreservCOImet <-rPreservCOI[row.names(rPreservCOI) %in% unique(c(as.character(strictCOItaxonomy$V1),as.character(relaxedCOItaxonomy$V1))),]

rPreserv18SOTUmet <- data.frame("sample"=names(rPreserv18Smet),"OTUnum"=unname(apply(rPreserv18Smet,2,counter)))
#get rid of leading makrer name
rPreserv18SOTUmet$sample <- rPreserv18SOTUmet$sample %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
rPreserv18SOTUmet <- rPreserv18SOTUmet[-grep("S.[0-9][0-9]",rPreserv18SOTUmet$sample),]
#Turn names into conds
rPreserv18SOTUmet <-separate(rPreserv18SOTUmet,sample,into=c('site',"cond"))
rPreserv18SOTUmet$rep <- substr(rPreserv18SOTUmet$site,3,3)
rPreserv18SOTUmet$site <- strsplit(rPreserv18SOTUmet$site,"[0-9]")
rPreserv18SOTUmet$site <- unlist(rPreserv18SOTUmet$site)
rPreserv18SOTUmet$site <- as.factor(rPreserv18SOTUmet$site)
rPreserv18SOTUmet$rep <- as.factor(rPreserv18SOTUmet$rep)
rPreserv18SOTUmet$cond <- as.factor(rPreserv18SOTUmet$cond)


rPreservCOIOTUmet <- data.frame("sample"=names(rPreservCOImet),"OTUnum"=unname(apply(rPreservCOImet,2,counter)))
#get rid of leading makrer name
rPreservCOIOTUmet$sample <- rPreservCOIOTUmet$sample %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
rPreservCOIOTUmet <- rPreservCOIOTUmet[-grep("S.[0-9][0-9]",rPreservCOIOTUmet$sample),]
#Turn names into conds
rPreservCOIOTUmet <-separate(rPreservCOIOTUmet,sample,into=c('site',"cond"))
rPreservCOIOTUmet$rep <- substr(rPreservCOIOTUmet$site,3,3)
rPreservCOIOTUmet$site <- strsplit(rPreservCOIOTUmet$site,"[0-9]")
rPreservCOIOTUmet$site <- unlist(rPreservCOIOTUmet$site)
rPreservCOIOTUmet$site <- as.factor(rPreservCOIOTUmet$site)
rPreservCOIOTUmet$rep <- as.factor(rPreservCOIOTUmet$rep)
rPreservCOIOTUmet$cond <- as.factor(rPreservCOIOTUmet$cond)

pdf(file="../figures/Preserv_met.pdf",width=8,height=4)
par(mfrow=c(1,2))
boxplot(rPreserv18SOTUmet$OTUnum~rPreserv18SOTUmet$cond+rPreserv18SOTUmet$site,xlab="Condition-Site",ylab="MetazoanOTUs",main="18S", col = rep(c("#E69F00","#0072B2"),4),las=2)
boxplot(rPreservCOIOTUmet$OTUnum~rPreservCOIOTUmet$cond+rPreservCOIOTUmet$site,xlab="Condition-Site",ylab="MetazoanOTUs",main="COI", col = rep(c("#E69F00","#0072B2"),4),las=2)
dev.off()

##Statistics

##ALL data

#Parametric
#Significant difference in 18S
t.test(rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="L"],rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="N"],paired=TRUE)
#No difference in COI 
t.test(rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="L"],rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="N"],paired=TRUE)

#Non-Parametric
#Significant difference in 18S
wilcox.test(rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="L"],rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="N"],paired=TRUE)
#No difference in COI 
wilcox.test(rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="L"],rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="N"],paired=TRUE)

##Just metazoan

#Sig diff in 18S
t.test(rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="L"],rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="N"],paired=TRUE)
#No difference in COI 
t.test(rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="L"],rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="N"],paired=TRUE)

#Non-Parametric
#Significant difference in 18S
wilcox.test(rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="L"],rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="N"],paired=TRUE)
#No difference in COI 
wilcox.test(rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="L"],rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="N"],paired=TRUE)

#Lets see at what number of reads the difference is no longer siginificant



datasets <-c("rPreserv18S","rPreserv18Smet","rPreservCOI","rPreservCOImet")
Pbootresults <- as.data.frame(matrix(data=NA,ncol=5,nrow = length(3:200)))
names(Pbootresults) <- c("MinReads",datasets)
Pbootresults$MinReads <- 3:200  
Pbootresultsdir <- Pbootresults
colcount <-2
for (dataset in names(Pbootresults[2:5])){

inputdataO <-get(dataset)
  
bootcount <- 1

for (minR in 3:200){
  inputdata <- inputdataO
  inputdata[inputdata< minR] <- 0
  inputdata <- inputdata[rowSums(inputdata) > 0,]
  
  inputdataOTU <- data.frame("sample"=names(inputdata),"OTUnum"=unname(apply(inputdata,2,counter)))
  #get rid of leading makrer name
  inputdataOTU$sample <- inputdataOTU$sample %>%  
  {gsub("^[A-Z]*","",.)} %>%
  {gsub("^[a-z]*[:.:]","",.)}
  #take out sediment samples
  inputdataOTU <- inputdataOTU[-grep("S.[0-9][0-9]",inputdataOTU$sample),]
  #Turn names into conds
  inputdataOTU <-separate(inputdataOTU,sample,into=c('site',"cond"))
  inputdataOTU$rep <- substr(inputdataOTU$site,3,3)
  inputdataOTU$site <- strsplit(inputdataOTU$site,"[0-9]")
  inputdataOTU$site <- unlist(inputdataOTU$site)
  inputdataOTU$site <- as.factor(inputdataOTU$site)
  inputdataOTU$rep <- as.factor(inputdataOTU$rep)
  inputdataOTU$cond <- as.factor(inputdataOTU$cond)
  
  item <-wilcox.test(inputdataOTU$OTUnum[inputdataOTU$cond=="L"],inputdataOTU$OTUnum[inputdataOTU$cond=="N"],paired=TRUE)
  Pbootresults[bootcount,colcount] <- item$p.value
  if(item$p.value<0.05){
    
    Pbootresultsdir[bootcount,colcount] <-ifelse(mean(inputdataOTU$OTUnum[inputdataOTU$cond=="L"])>mean(inputdataOTU$OTUnum[inputdataOTU$cond=="N"]),"6","2")
    
  }
  
  bootcount <- bootcount+1
  
}
colcount <- colcount+1
}

#Lets plot these to examine how read truncation affects differences
plot(Pbootresults$MinReads,Pbootresults$rPreserv18S,type="l",col="green",ylim=c(-0.1,1),xlab="Number of normalised reads at truncation",ylab="Wilcoxon P Value")
points(Pbootresults$MinReads,Pbootresults$rPreserv18Smet,type="l",col="darkgreen")
points(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreserv18S)],rep(-0.02,length(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreserv18S)])),pch=as.numeric(Pbootresultsdir$rPreserv18S[!is.na(Pbootresultsdir$rPreserv18S)]),col="green",cex=0.3)
points(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreserv18Smet)],rep(-0.04,length(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreserv18Smet)])),pch=as.numeric(Pbootresultsdir$rPreserv18Smet[!is.na(Pbootresultsdir$rPreserv18Smet)]),col="darkgreen",cex=0.3)
points(Pbootresults$MinReads,Pbootresults$rPreservCOI,type="l",col="blue")
points(Pbootresults$MinReads,Pbootresults$rPreservCOImet,type="l",col="darkblue")
points(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreservCOI)],rep(-0.06,length(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreservCOI)])),pch=as.numeric(Pbootresultsdir$rPreservCOI[!is.na(Pbootresultsdir$rPreservCOI)]),col="blue",cex=0.3)
points(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreservCOImet)],rep(-0.08,length(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreservCOImet)])),pch=as.numeric(Pbootresultsdir$rPreservCOImet[!is.na(Pbootresultsdir$rPreservCOImet)]),col="darkblue",cex=0.3)
abline(h=0.05,lty=3,col="red")
legend("topleft",legend=c("18S","18Smetazoan","COI","COImetazoan"),col=c("green","darkgreen","blue","darkblue"),lty = 1,cex=0.5)

##Lets make the permanova dataset

PERM18Slong <- rPreserv18S[,substr(names(rPreserv18S),7,7)=="L"]
PERM18Sfroz <- rPreserv18S[,substr(names(rPreserv18S),7,7)=="N"]

test <- rbind(t(PERM18Slong),t(PERM18Sfroz))

treatment <- c(rep("L",12),rep("N",12))
sites <- rep(c(rep("1",3),rep("2",3),rep("3",3),rep("4",3)),2)

PERMresults.18S.P <- adonis(test~treatment/sites,method="bray",perm=999)
PERMresults.18S.S <- adonis(test~sites,method="bray",perm=9999)

#We see highly significant differences between sites and no difference between treatments
##Lets make the permanova dataset

PERMCOIlong <- rPreservCOI[,substr(names(rPreservCOI),7,7)=="L"]
PERMCOIfroz <- rPreservCOI[,substr(names(rPreservCOI),7,7)=="N"]

test <- rbind(t(PERMCOIlong),t(PERMCOIfroz))

treatment <- c(rep("L",12),rep("N",12))
sites <- rep(c(rep("1",3),rep("2",3),rep("3",3),rep("4",3)),2)

PERMresults.COI.P <- adonis(test~treatment/sites,method="bray",perm=999)
PERMresults.COI.S <- adonis(test~sites,method="bray",perm=9999)





#Groups not significantly different 


#### Sediment or Water ####

#First lets visualise the difference in 2d using nMDS

#18S

t18sdat <- t(rPreserv18S) 
MDS18s <- metaMDS(t18sdat)
nMDSdata18s <-as.data.frame(MDS18s$points)
nMDS18Sstress <- MDS18s$stress

#Here we rename the sediment samples to make life easier
row.names(nMDSdata18s)[13:21] <- paste("Z.",as.character(sedimentID$Code),sep="")
#Now we put in factors to help with plotting 
row.names(nMDSdata18s) <- substr(row.names(nMDSdata18s),3,7)
nMDSdata18s$site <- substr(row.names(nMDSdata18s),1,2)
nMDSdata18s$type <- substr(row.names(nMDSdata18s),5,5)
nMDSdata18s$site.type <- paste(nMDSdata18s$site,nMDSdata18s$type,sep='.')

#great, lets throw in the same data for the metazoan only data
t18sdat <- t(rPreserv18Smet)
MDS18s <- metaMDS(t18sdat)
nMDSdata18s <- cbind(nMDSdata18s,as.data.frame(MDS18s$points))
names(nMDSdata18s)[6:7] <- c("MDS1met","MDS2met")
nMDS18Smetstress <- MDS18s$stress

##The 18S data is ready for visualisation
#Now the COI
tCOIdat <- t(rPreservCOI) 
MDSCOI <- metaMDS(tCOIdat)
nMDSdataCOI <-as.data.frame(MDSCOI$points)
nMDSCOIstress <- MDSCOI$stress

#Here we rename the sediment samples to make life easier
row.names(nMDSdataCOI)[13:21] <- paste("Z.",as.character(sedimentID$Code),sep="")
#Now we put in factors to help with plotting 
row.names(nMDSdataCOI) <- substr(row.names(nMDSdataCOI),3,7)
nMDSdataCOI$site <- substr(row.names(nMDSdataCOI),1,2)
nMDSdataCOI$type <- substr(row.names(nMDSdataCOI),5,5)
nMDSdataCOI$site.type <- paste(nMDSdataCOI$site,nMDSdataCOI$type,sep='.')

#great, lets throw in the same data for the metazoan only data
tCOIdat <- t(rPreservCOImet)
MDSCOI <- metaMDS(tCOIdat)
nMDSdataCOI <- cbind(nMDSdataCOI,as.data.frame(MDSCOI$points))
names(nMDSdataCOI)[6:7] <- c("MDS1met","MDS2met")
nMDSCOImetstress <- MDSCOI$stress


##Now lets plot
#Set up a custom palette for colourblind safe plotting
pdf(file="../figures/nMDS18S.pdf",width=11,height=6)
par(mfrow=c(1,2))
palette(c("#8c96c6","#8856a7","#66c2a4","#2ca25f","#006d2c","#7bccc4","#43a2ca","#0868ac","#fc8d59","#e34a33","#b30000"))
plot(nMDSdata18s$MDS1,nMDSdata18s$MDS2,col=as.factor(nMDSdata18s$site.type),xlab="MDS1",ylab="MDS2",pch=16,cex=2,main="18S all")
text(-1.2,1.6,paste("Stress = ",round(nMDS18Sstress,digits = 3),sep=''))
plot(nMDSdata18s$MDS1met,nMDSdata18s$MDS2met,col=as.factor(nMDSdata18s$site.type),pch=16,xlab="MDS1",ylab="MDS2",cex=2,main="18S metazoan")
text(-1,1.85,paste("Stress = ",round(nMDS18Smetstress,digits = 3),sep=''))
dev.off()

pdf(file="../figures/nMDSCOI.pdf",width=11,height=6)
par(mfrow=c(1,2))
plot(nMDSdataCOI$MDS1,nMDSdataCOI$MDS2,col=as.factor(nMDSdataCOI$site.type),pch=16,xlab="MDS1",ylab="MDS2",cex=2,main="COI all")
text(-1.8,3.65,paste("Stress = ",round(nMDSCOIstress,digits = 3),sep=''))
plot(nMDSdataCOI$MDS1met,nMDSdataCOI$MDS2met,col=as.factor(nMDSdataCOI$site.type),pch=16,xlab="MDS1",ylab="MDS2",cex=2,main="COI metazoan")
text(-2,3.9,paste("Stress = ",round(nMDSCOImetstress,digits = 3),sep=''))
dev.off()


barplot(rep(100,11),col=1:11,names.arg = levels(as.factor(nMDSdata18s$site.type)),axes=F)


#now we have some broad details letting us know there are some differenes between sediment and water, lets see which groups are driving this difference
#First we need to annotate the taxonomy and create a dataset with only annotated OTUs


##COI

#first subset the data by observations that have assigned taxonomy
annotatedCOI <- rPreservCOI[rownames(rPreservCOI) %in% strictCOItaxonomy$V1,]
#now put in a column with the assignments
strictCOItaxonomy$assignment <- paste(strictCOItaxonomy$V3,strictCOItaxonomy$V4)
annotatedCOI$assignment <- strictCOItaxonomy$assignment[match(row.names(annotatedCOI),strictCOItaxonomy$V1)]
#now lets clean up the column so it only contains taxonomy tree
annotatedCOI$assignment <- gsub(".*root;(.*)","\\1",annotatedCOI$assignment)
#now lets collapse the data into site-sediment comparisons, excluding HH
treedatCOI <- data.frame("PQ.W"=rowSums(annotatedCOI[7:12]),"PQ.S"=rowSums(annotatedCOI[13:15]),"TB.W"=rowSums(annotatedCOI[22:27]),"TB.S"=rowSums(annotatedCOI[16:18]),"TQ.W"=rowSums(annotatedCOI[28:33]),"TQ.S"=rowSums(annotatedCOI[19:21]),"assignment"=annotatedCOI$assignment)

#Great now lets class each OTU into sediment, water, both or neither catagories per site

treedatCOI$PQ.stat <- ifelse(treedatCOI$PQ.W>0 & treedatCOI$PQ.S>0,"B",ifelse(treedatCOI$PQ.W>0 & treedatCOI$PQ.S==0,"w",ifelse(treedatCOI$PQ.W==0 & treedatCOI$PQ.S>0,"s",ifelse(treedatCOI$PQ.W==0 & treedatCOI$PQ.S==0,"n","error"))))
treedatCOI$TB.stat <- ifelse(treedatCOI$TB.W>0 & treedatCOI$TB.S>0,"B",ifelse(treedatCOI$TB.W>0 & treedatCOI$TB.S==0,"w",ifelse(treedatCOI$TB.W==0 & treedatCOI$TB.S>0,"s",ifelse(treedatCOI$TB.W==0 & treedatCOI$TB.S==0,"n","error"))))
treedatCOI$TQ.stat <- ifelse(treedatCOI$TQ.W>0 & treedatCOI$TQ.S>0,"B",ifelse(treedatCOI$TQ.W>0 & treedatCOI$TQ.S==0,"w",ifelse(treedatCOI$TQ.W==0 & treedatCOI$TQ.S>0,"s",ifelse(treedatCOI$TQ.W==0 & treedatCOI$TQ.S==0,"n","error"))))

treedatCOI$all.stat <- "nonexclusive"

for (number in 1:length(treedatCOI$PQ.W)){

 items <-  unique(c(treedatCOI$PQ.stat[number],treedatCOI$TB.stat[number],treedatCOI$TQ.stat[number]))  
 items <- items[items!='n' ]
 if (length(unique(items))>1){treedatCOI$all.stat[number] <- "nonexclisive"} else {
   if(length(unique(items))<1){treedatCOI$all.stat[number] <- "none"}else{if (unique(items=="w")){treedatCOI$all.stat[number] <- "water"}else{if (unique(items=="s")){treedatCOI$all.stat[number] <- "sediment"}}}}
 
}  
  
  

#18S


#first subset the data by observations that have assigned taxonomy
annotated18S <- rPreserv18S[rownames(rPreserv18S) %in% strict18Staxonomy$V1,]
#now put in a column with the assignments
annotated18S$assignment <- strict18Staxonomy$V2[match(row.names(annotated18S),strict18Staxonomy$V1)]
#now lets clean up the column so it only contains taxonomy tree
annotated18S$assignment <- gsub(".*(Eukaryota.*)","\\1",annotated18S$assignment)
#now lets collapse the data into site-sediment comparisons, excluding HH
treedat18S <- data.frame("PQ.W"=rowSums(annotated18S[7:12]),"PQ.S"=rowSums(annotated18S[13:15]),"TB.W"=rowSums(annotated18S[22:27]),"TB.S"=rowSums(annotated18S[16:18]),"TQ.W"=rowSums(annotated18S[28:33]),"TQ.S"=rowSums(annotated18S[19:21]),"assignment"=annotated18S$assignment)

#Great now lets class each OTU into sediment, water, both or neither catagories per site

treedat18S$PQ.stat <- ifelse(treedat18S$PQ.W>0 & treedat18S$PQ.S>0,"B",ifelse(treedat18S$PQ.W>0 & treedat18S$PQ.S==0,"w",ifelse(treedat18S$PQ.W==0 & treedat18S$PQ.S>0,"s",ifelse(treedat18S$PQ.W==0 & treedat18S$PQ.S==0,"n","error"))))
treedat18S$TB.stat <- ifelse(treedat18S$TB.W>0 & treedat18S$TB.S>0,"B",ifelse(treedat18S$TB.W>0 & treedat18S$TB.S==0,"w",ifelse(treedat18S$TB.W==0 & treedat18S$TB.S>0,"s",ifelse(treedat18S$TB.W==0 & treedat18S$TB.S==0,"n","error"))))
treedat18S$TQ.stat <- ifelse(treedat18S$TQ.W>0 & treedat18S$TQ.S>0,"B",ifelse(treedat18S$TQ.W>0 & treedat18S$TQ.S==0,"w",ifelse(treedat18S$TQ.W==0 & treedat18S$TQ.S>0,"s",ifelse(treedat18S$TQ.W==0 & treedat18S$TQ.S==0,"n","error"))))

treedat18S$all.stat <- "nonexclusive"

for (number in 1:length(treedat18S$PQ.W)){
  
  items <-  unique(c(treedat18S$PQ.stat[number],treedat18S$TB.stat[number],treedat18S$TQ.stat[number]))  
  items <- items[items!='n' ]
  if (length(unique(items))>1){treedat18S$all.stat[number] <- "nonexclusive"} else {
    if(length(unique(items))<1){treedat18S$all.stat[number] <- "none"}else{if (unique(items=="w")){treedat18S$all.stat[number] <- "water"}else{if (unique(items=="s")){treedat18S$all.stat[number] <- "sediment"}}}}
  
}  

table(treedat18S$all.stat)

###Notes - when you redo this analysis on raw data (no taxonomic subsetting) you get greater diversity in sediment for both 18S and COI.

##Output data for WIRMS

WIRMSoutput <- data.frame("ID"=c(rownames(annotated18S),rownames(annotatedCOI)),"dataset"=c(rep("18S",length(rownames(annotated18S))),rep("COI",length(rownames(annotatedCOI)))),"annotation"=c(annotated18S$assignment,annotatedCOI$assignment))

#This expression uses regex to take everything after the last semicolon. It is broken by non alpha numeric characters
WIRMSoutput$species  <- gsub(".*;([A-z0-9 -]*)$","\\1",WIRMSoutput$annotation)

#Some of the entries ae amnbiguous eg. Flabellual sp. so the extra characters breaks the regex. We can seperate these out now and 
#make a clean dataset

WIRMSoutput <- WIRMSoutput[nchar(WIRMSoutput$species)<50,]

write.csv(WIRMSoutput,file="../WIRMSdata.csv")




##Now lets consider the difference between 18S and COI 

#Ideas

#Two heat maps of bray curtis dissisimilarity with a map in the middle showing the difference in the same colour range
###this might be dragged towards smoothing over idfferences if the total range is high. What is an ecologically relevant amount
###of dissimilarity?

#Corrolation maps of dissimilarity
###MOst of this diagram with be taken up with the expression of the range of dissimilarity


#An initial starting point is to generate dissimilarity matrixes





#### The code basement ####


#This function returns the number of non zero values in an object. The apply statement below runs it across columns
counter <- function(x){
  temp <- x
  temp[temp>0] <- 1
  return(sum(temp))
  rm(temp)
}
apply(samples,2,counter)


#Metacoder Trees

test <- parse_tax_data(treedatCOI, class_cols = "assignment", class_sep = ";")
test

test$data$tax_abund <- calc_taxon_abund(test, "tax_data",
                                        cols = 2:7)

pdf(file="~/Desktop/TB.w.pdf")
heat_tree(test,node_label = taxon_names, node_color =test$data$tax_abund$TB.W, node_size = n_obs,node_size_axis_label = "OTU count",node_color_axis_label = "Samples with reads")
dev.off()
pdf(file="~/Desktop/TB.s.pdf")
heat_tree(test,node_label = taxon_names, node_color =test$data$tax_abund$TB.S, node_size = n_obs,node_size_axis_label = "OTU count",node_color_axis_label = "Samples with reads")
dev.off()


test$data$diff_table <- compare_groups(test, dataset = "tax_abund",
                                       groups = as.factor(rep(c("1","2"),3)),cols=names(treedatCOI)[1:6])
pdf(file="~/Desktop/diff.pdf")
heat_tree(test, 
          node_label = taxon_names,
          node_size = n_obs,
          node_color = log2_median_ratio, 
          node_color_interval = c(-2, 2),
          edge_color_interval = c(-2, 2),
          node_color_range = c("cyan", "gray", "tan"),
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median proportions")
dev.off()



