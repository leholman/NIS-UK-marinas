###### Analysis of raw data for UK marinas 

#Load in packages
library("dplyr")
library("vegan")
library("reshape")
library("reshape2")
library("ggplot2")
library("stringr")
library("tidyr")
library("RColorBrewer")
library("metacoder")
library("readxl")

#Set some variables 
minreads <- 3
items <- NULL

#Set the seed 
set.seed("123456")

#Set wd and load up sediment data 
setwd("~/Desktop/AnalysisUKMarinaData/raw.data/")
sedimentID <- read.csv(file="../sedimentdata.csv")

#### Data Cleaning ####
files <- system2('ls',stdout=TRUE)

for (file in  files){
  
  rawdat <-read.csv(file=file)
  
  #remove samples that are not to be analysed, these are labelled 'other' in the location metadata
  metadat <- read.csv(file="../locations.csv",sep=",",header=T)
  seddat <- read.csv(file="../sedimentdata.csv",sep=",",header=T)
  rawdat <- rawdat[colnames(rawdat) %in% metadat$RealID[metadat$Type!="other"]]
  
  
  #Seperate controls and samples
  samples <- rawdat[colnames(rawdat) %in% metadat$RealID[metadat$Type=="sample"]]
  controls <- rawdat[colnames(rawdat) %in% metadat$RealID[metadat$Type=="control"]]
  
  
  #Filter 1 - minimum number of reads for any ID
  samples[samples< minreads] <- 0
  samples <- samples[rowSums(samples) > 0,]
  
  #Filter 2 - within samples OTU must appear in more than one sample (this works becuase there are lots of reps per site and sample)
  filtersam <- samples
  filtersam[filtersam>0 ] <- 1
  filtersam <-filtersam[rowSums(filtersam) > 1,]
  samples <- samples[rownames(samples) %in% rownames(filtersam),]
  
  #Filter 3 -Remove any OTU found in the negative control samples
  controlsCONTAM <- controls[rowSums(controls) > 0,]
  samples <- samples[!(rownames(samples) %in% rownames(controlsCONTAM)),]
  
  
  #Now we write out the cleaned data
  newname <- paste("../cleaned/","Cleaned.",file,sep="")
  write.csv(samples,file=newname)
  
}

#### All samples cleaned ####

#### LULU Effects ####


###Now we want to see what effect LULU has on our data, we know it decreases the number of OTUs but lets produce a table contain pre and post LULU OTU number per OTU clusting method

setwd(dir = "../cleaned/")
files <- system2('ls',stdout=TRUE)

OTUcount <- data.frame("File"=rep("NA",length(files)),"OTUcount"=rep("NA",length(files)))
OTUcount$File <- as.character(OTUcount$File)
OTUcount$OTUcount <- as.numeric(OTUcount$OTUcount)
count <- 1
for (file in files){

  samples <- read.csv(file = file,sep=",",header=TRUE)
  runninglength <- length(samples[,1])
  OTUcount[count,]<- c(file,runninglength)
count <- count+1
}

OTUcount <- cbind(OTUcount[grep("lulu",OTUcount$File),],OTUcount[grep("lulu",OTUcount$File,invert=TRUE),2])
colnames(OTUcount)[3] <- "OTUraw"
colnames(OTUcount)[2] <- "OTUlulu"

#Lets plot a little stacked barplot

pdf(file="../figures/LULUeffect.pdf",width=8.95,height=6.3)
OTUcountT <- as.matrix(t(OTUcount[-1]))
par(mfrow=c(1,1))
par(mar=c(6.1,4.1,4.1,2.1))
barplot(as.numeric(OTUcountT[2,]),col="red",ylim=c(0,12000),ylab="Number of OTUs",names.arg = c("COI.0.97","COI.swarm","COI.unoise","18S.0.97","18S.swarm","18S.unoise"),las=2)
par(new=T)
barplot(as.numeric(OTUcountT[1,]), col='skyblue',ylim=c(0,12000),axes = F)
legend("topright",c("Pre-LULU","Post-LULU"),fill=c("red","skyblue"), bty = "n")
dev.off()

 #There is a clear positive effect on LULU on the dataset. Analyses will proceed using LULU 

#### OTU CLustering Effect ####
#Count number of OTUs in dataset
## Alpha diversity estimates as a result of bioinformatics
###Here we are asking the question do we see more or less OTUs generated by different methods
#We may also ask if by truncating at different numbers of minimum reads converges on a estimate???

#This section assumes all input files have the same number of observations in the same order, it will not work otherwise

#First we get the observation names and create a dataframe to store our results in
spark <- read.csv(file=file[1],sep=",",header=TRUE)
spark <- spark[-1]
files <- files[grep("lulu",files)]
OTUcountbymethod <- as.data.frame(matrix(data=NA,nrow=length(files),ncol=length(colnames(spark))))
colnames(OTUcountbymethod) <- substr(colnames(spark),3,10)
#Cheat to rename cols
colnames(OTUcountbymethod)[13:21] <- as.character(seddat$Code)


count <- 1
for (file in  files){

  loopdata <- read.csv(file=file,sep=",",header=TRUE)
  loopdata <-loopdata[-1]
  
  counter <- function(x){
    temp <- x
    temp[temp>0] <- 1
    return(sum(temp))
    rm(temp)
  }
  loopresults <- apply(loopdata,2,counter)
  OTUcountbymethod[count,] <- unname(loopresults)
   count <- count +1
}
    
#This bit is specific to the data structure, we need to wrangle the data into a long form for plots and stats with OTU no as a responce variable 

OTUcountbymethod$Marker <- substr(files,9,9)  
OTUcountbymethod$OTUclust <- files %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)} %>%
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)} %>%
{gsub("[:.:][a-z]*$","",.)} 

OTUcountbymethod <- OTUcountbymethod %>%
gather("code","OTUnum",1:33) 
OTUcountmethod <- OTUcountbymethod
OTUcountbymethod <- dcast(OTUcountbymethod,code+Marker~OTUclust,value.var="OTUnum")

OTUcountbymethod <-  melt(OTUcountbymethod)
OTUcountbymethod <-rename(OTUcountbymethod,c("variable"="OTUclust","value"="OTUnum"))
OTUcountbymethod <- OTUcountbymethod %>%
separate(code, c("site", "cond")) %>%
separate(site, c("site","rep"),sep=2)

cols <- 1:5
OTUcountbymethod[cols] <- lapply(OTUcountbymethod[cols], factor)
OTUcountbymethod$cond2 <- as.character(OTUcountbymethod$cond) 
OTUcountbymethod$cond2[OTUcountbymethod$cond2=="L"] <- "W"
OTUcountbymethod$cond2[OTUcountbymethod$cond2=="N"] <- "W"
OTUcountbymethod$cond2 <- as.factor(OTUcountbymethod$cond2)

#Now the data is in a long format suitable for figures and statistics.

#First lets seperate out the markers and look at the effects of OTU clustering
resultsZ <- OTUcountbymethod[OTUcountbymethod$Marker=="Z",]
resultsL <- OTUcountbymethod[OTUcountbymethod$Marker=="L",]

pdf(file="../figures/OTUclusteringeffect.pdf",width=11,height=8)
palette(brewer.pal(8,"Set1"))
par(mfrow=c(1,2))        
par(mar=c(7.1,4.1,4.1,2.1))
    

boxplot(resultsL$OTUnum~resultsL$OTUclust+resultsL$site+resultsL$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,las=2,ylab="Number of OTUs",main="COI",ylim=c(450,2800))
rect(-10,0,9.48,4000, col=rgb(0.1,0.1,0.1,alpha=0.35),xpd=F,lwd=0)
boxplot(resultsL$OTUnum~resultsL$OTUclust+resultsL$site+resultsL$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,axes=F,add=T,ylim=c(450,2800))
legend("topright",c("0.97","swarm","unoise3"),fill=brewer.pal(3,"Set1"), bty = "n")
text(3,480,col="white",labels="Sediment",cex=0.75)
text(20,480,col="Black",labels="Water",cex=0.75)


boxplot(resultsZ$OTUnum~resultsZ$OTUclust+resultsZ$site+resultsZ$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,las=2,ylab="Number of OTUs",main="18S",ylim=c(-100,2300))
rect(-1000,-1000,9.48,4000, col=rgb(0.1,0.1,0.1,alpha=0.35),xpd=F,lwd=0)
boxplot(resultsZ$OTUnum~resultsZ$OTUclust+resultsZ$site+resultsZ$cond2, col=brewer.pal(3,"Set1"),drop = TRUE,axes=F,add=T,ylim=c(-100,2300))
legend("topright",c("0.97","swarm","unoise3"),fill=brewer.pal(3,"Set1"), bty = "n")
text(3,-50,col="white",labels="Sediment",cex=0.75)
text(20,-50,col="Black",labels="Water",cex=0.75)

dev.off()

#Now we want to look at beta diversity, we are not normlising here either as comparisons are not being made between sites


files <- system2('ls',stdout=TRUE)
files <- files[grep("lulu",files)]
BdivOTUresults <- as.data.frame(matrix(ncol = length(files),nrow=528))
colnames(BdivOTUresults) <- files

count <- 1
for (file in  files){

  loopdata <- read.csv(file=file,sep=",",header=TRUE)
  loopdata <- loopdata[-1]
  
  OTU.count.distance<-as.matrix(vegdist(t(loopdata), method="bray", upper=FALSE, binary=F))
  OTU.count.distance[lower.tri(OTU.count.distance)] <- NA
  
  pairwise <- melt(OTU.count.distance)
  pairwise <- pairwise[!is.na(pairwise$value),]
  pairwise <- pairwise[pairwise$value>0,]
  
  BdivOTUresults[,count] <- pairwise$value
  
  count <- count+1
}  

#Plotting bray-curtis values for each OTU generating method against each other tests community similarity across methods  
pdf(file="../figures/OTUclusting_BC_COI.pdf")
plot(BdivOTUresults[,1:3])
dev.off()
pdf(file="../figures/OTUclusting_BC_18S.pdf")
plot(BdivOTUresults[,4:6])
dev.off()

##Overall it seems that b diversity information is similar regardless of OTU generation used. We dont want to use 0.97 becuase we know it doesnt represent the biological reality, we dont want to use swarm becuase it generates many more OTUs than possible as it isnt able to deal with errors in Illumina data. unoise3 is best as it attempts to recreate biological seqs. 

#Now we can start dealing with variables of interest to our study. 

#### Longmire's or Freezing ####

#First we need to rarefy our data to make sensible comparisons between sites/conditions
#Read in data
  Preserv18S <- read.table(file="Cleaned.Zhanlulu.unoise3.csv",row.names = 1,sep=",",header=TRUE)

#Rarefy

rPreserv18S<-
  Preserv18S%>%
  filter(rowSums(.)>0)%>%
  t(.)%>%
  rarecurve(.,step=100)


rPreserv18S<-
  Preserv18S%>%
  filter(rowSums(.)>0)%>%
  t(.)%>%
  rrarefy(.,min(rowSums(.)))%>%
  t(.)

rPreserv18S <- as.data.frame(rPreserv18S,row.names = row.names(Preserv18S))


rPreserv18SOTU <- data.frame("sample"=names(rPreserv18S),"OTUnum"=unname(apply(rPreserv18S,2,counter)))
#get rid of leading makrer name
rPreserv18SOTU$sample <- rPreserv18SOTU$sample %>%  
  {gsub("^[A-Z]*","",.)} %>%
  {gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
rPreserv18SOTU <- rPreserv18SOTU[-grep("S.[0-9][0-9]",rPreserv18SOTU$sample),]
#Turn names into conds
rPreserv18SOTU <-separate(rPreserv18SOTU,sample,into=c('site','cond'),sep=4)
rPreserv18SOTU$rep <- substr(rPreserv18SOTU$site,3,3)
rPreserv18SOTU$site <- substr(rPreserv18SOTU$site,1,2)
rPreserv18SOTU$site <- as.factor(rPreserv18SOTU$site)
rPreserv18SOTU$rep <- as.factor(rPreserv18SOTU$rep)
rPreserv18SOTU$cond <- as.factor(rPreserv18SOTU$cond)


#Now the same for COI
PreservCOI <- read.table(file="~/Desktop/AnalysisUKMarinaData/cleaned/Cleaned.Leraylulu.unoise3.csv",row.names = 1,sep=",",header=TRUE)

minimumCOI <- min(colSums(PreservCOI))

#Rarefy

rPreservCOI<-
  PreservCOI%>%
  filter(rowSums(.)>0)%>%
  t(.)%>%
  rarecurve(.,step=100)

rPreservCOI<-
    PreservCOI%>%
    filter(rowSums(.)>0)%>%
    t(.)%>%
    rrarefy(.,min(rowSums(.)))%>%
    t(.)
rPreservCOI <- as.data.frame(rPreservCOI,row.names = row.names(PreservCOI))
rPreservCOIOTU <- data.frame("sample"=names(rPreservCOI),"OTUnum"=unname(apply(rPreservCOI,2,counter)))
#get rid of leading makrer name
  rPreservCOIOTU$sample <- rPreservCOIOTU$sample %>%  
  {gsub("^[A-Z]*","",.)} %>%
  {gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
  rPreservCOIOTU <- rPreservCOIOTU[-grep("S.[0-9][0-9]",rPreservCOIOTU$sample),]
#Turn names into conds
  rPreservCOIOTU <-separate(rPreservCOIOTU,sample,into=c('site',"cond"))
rPreservCOIOTU$rep <- substr(rPreservCOIOTU$site,3,3)
rPreservCOIOTU$site <- strsplit(rPreservCOIOTU$site,"[0-9]")
rPreservCOIOTU$site <- unlist(rPreservCOIOTU$site)
rPreservCOIOTU$site <- as.factor(rPreservCOIOTU$site)
rPreservCOIOTU$rep <- as.factor(rPreservCOIOTU$rep)
rPreservCOIOTU$cond <- as.factor(rPreservCOIOTU$cond)

pdf(file="../figures/Preserv_all.pdf",width=8,height=4)
par(mfrow=c(1,2))
boxplot(rPreserv18SOTU$OTUnum~rPreserv18SOTU$cond+rPreserv18SOTU$site,xlab="Condition-Site",ylab="OTUs",main="18S", col = rep(c("#E69F00","#0072B2"),4),las=2)
boxplot(rPreservCOIOTU$OTUnum~rPreservCOIOTU$cond+rPreservCOIOTU$site,xlab="Condition-Site",ylab="OTUs",main="COI", col = rep(c("#E69F00","#0072B2"),4),las=2)
dev.off()

#Brilliant now lets see how this pattern interacts with taxonomy

#Read in the taxonomy

strict18Staxonomy <- read.table(file="../taxonomy/18S_SILVA_results.txt",sep="\t")
relaxed18Staxonomy <- read.table(file = "../taxonomy/18SMEGAN_met.txt",sep=",")

strictCOItaxonomy <- read.table(file="../taxonomy/COI_MIDORI_results.txt")
relaxedCOItaxonomy <- read.table(file="../taxonomy/COIMEGAN_met.txt",sep=",")

#Now lets subset the data by the taxonomy 

rPreserv18Smet <-rPreserv18S[row.names(rPreserv18S) %in% unique(c(as.character(strict18Staxonomy$V1),as.character(relaxed18Staxonomy$V1))),]
rPreservCOImet <-rPreservCOI[row.names(rPreservCOI) %in% unique(c(as.character(strictCOItaxonomy$V1),as.character(relaxedCOItaxonomy$V1))),]

rPreserv18SOTUmet <- data.frame("sample"=names(rPreserv18Smet),"OTUnum"=unname(apply(rPreserv18Smet,2,counter)))
#get rid of leading makrer name
rPreserv18SOTUmet$sample <- rPreserv18SOTUmet$sample %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
rPreserv18SOTUmet <- rPreserv18SOTUmet[-grep("S.[0-9][0-9]",rPreserv18SOTUmet$sample),]
#Turn names into conds
rPreserv18SOTUmet <-separate(rPreserv18SOTUmet,sample,into=c('site',"cond"))
rPreserv18SOTUmet$rep <- substr(rPreserv18SOTUmet$site,3,3)
rPreserv18SOTUmet$site <- strsplit(rPreserv18SOTUmet$site,"[0-9]")
rPreserv18SOTUmet$site <- unlist(rPreserv18SOTUmet$site)
rPreserv18SOTUmet$site <- as.factor(rPreserv18SOTUmet$site)
rPreserv18SOTUmet$rep <- as.factor(rPreserv18SOTUmet$rep)
rPreserv18SOTUmet$cond <- as.factor(rPreserv18SOTUmet$cond)


rPreservCOIOTUmet <- data.frame("sample"=names(rPreservCOImet),"OTUnum"=unname(apply(rPreservCOImet,2,counter)))
#get rid of leading makrer name
rPreservCOIOTUmet$sample <- rPreservCOIOTUmet$sample %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)}
#take out sediment samples
rPreservCOIOTUmet <- rPreservCOIOTUmet[-grep("S.[0-9][0-9]",rPreservCOIOTUmet$sample),]
#Turn names into conds
rPreservCOIOTUmet <-separate(rPreservCOIOTUmet,sample,into=c('site',"cond"))
rPreservCOIOTUmet$rep <- substr(rPreservCOIOTUmet$site,3,3)
rPreservCOIOTUmet$site <- strsplit(rPreservCOIOTUmet$site,"[0-9]")
rPreservCOIOTUmet$site <- unlist(rPreservCOIOTUmet$site)
rPreservCOIOTUmet$site <- as.factor(rPreservCOIOTUmet$site)
rPreservCOIOTUmet$rep <- as.factor(rPreservCOIOTUmet$rep)
rPreservCOIOTUmet$cond <- as.factor(rPreservCOIOTUmet$cond)

pdf(file="../figures/Preserv_met.pdf",width=8,height=4)
par(mfrow=c(1,2))
boxplot(rPreserv18SOTUmet$OTUnum~rPreserv18SOTUmet$cond+rPreserv18SOTUmet$site,xlab="Condition-Site",ylab="MetazoanOTUs",main="18S", col = rep(c("#E69F00","#0072B2"),4),las=2)
boxplot(rPreservCOIOTUmet$OTUnum~rPreservCOIOTUmet$cond+rPreservCOIOTUmet$site,xlab="Condition-Site",ylab="MetazoanOTUs",main="COI", col = rep(c("#E69F00","#0072B2"),4),las=2)
dev.off()

##Statistics

##ALL data

#Parametric
#Significant difference in 18S
t.test(rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="L"],rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="N"],paired=TRUE)
#No difference in COI 
t.test(rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="L"],rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="N"],paired=TRUE)

#Non-Parametric
#Significant difference in 18S
wilcox.test(rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="L"],rPreserv18SOTU$OTUnum[rPreserv18SOTU$cond=="N"],paired=TRUE)
#No difference in COI 
wilcox.test(rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="L"],rPreservCOIOTU$OTUnum[rPreservCOIOTU$cond=="N"],paired=TRUE)

##Just metazoan

#Sig diff in 18S
t.test(rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="L"],rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="N"],paired=TRUE)
#No difference in COI 
t.test(rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="L"],rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="N"],paired=TRUE)

#Non-Parametric
#Significant difference in 18S
wilcox.test(rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="L"],rPreserv18SOTUmet$OTUnum[rPreserv18SOTUmet$cond=="N"],paired=TRUE)
#No difference in COI 
wilcox.test(rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="L"],rPreservCOIOTUmet$OTUnum[rPreservCOIOTUmet$cond=="N"],paired=TRUE)

#Lets see at what number of reads the difference is no longer siginificant



datasets <-c("rPreserv18S","rPreserv18Smet","rPreservCOI","rPreservCOImet")
Pbootresults <- as.data.frame(matrix(data=NA,ncol=5,nrow = length(1:200)))
names(Pbootresults) <- c("MinReads",datasets)
Pbootresults$MinReads <- 1:200  
Pbootresultsdir <- Pbootresults
colcount <-2
for (dataset in names(Pbootresults[2:5])){

inputdataO <-get(dataset)
  
bootcount <- 1

for (minR in 1:200){
  inputdata <- inputdataO
  inputdata[inputdata< minR] <- 0
  inputdata <- inputdata[rowSums(inputdata) > 0,]
  
  inputdataOTU <- data.frame("sample"=names(inputdata),"OTUnum"=unname(apply(inputdata,2,counter)))
  #get rid of leading makrer name
  inputdataOTU$sample <- inputdataOTU$sample %>%  
  {gsub("^[A-Z]*","",.)} %>%
  {gsub("^[a-z]*[:.:]","",.)}
  #take out sediment samples
  inputdataOTU <- inputdataOTU[-grep("S.[0-9][0-9]",inputdataOTU$sample),]
  #Turn names into conds
  inputdataOTU <-separate(inputdataOTU,sample,into=c('site',"cond"))
  inputdataOTU$rep <- substr(inputdataOTU$site,3,3)
  inputdataOTU$site <- strsplit(inputdataOTU$site,"[0-9]")
  inputdataOTU$site <- unlist(inputdataOTU$site)
  inputdataOTU$site <- as.factor(inputdataOTU$site)
  inputdataOTU$rep <- as.factor(inputdataOTU$rep)
  inputdataOTU$cond <- as.factor(inputdataOTU$cond)
  
  item <-wilcox.test(inputdataOTU$OTUnum[inputdataOTU$cond=="L"],inputdataOTU$OTUnum[inputdataOTU$cond=="N"],paired=TRUE)
  Pbootresults[bootcount,colcount] <- item$p.value
  if(item$p.value<0.05){
    
    Pbootresultsdir[bootcount,colcount] <-ifelse(mean(inputdataOTU$OTUnum[inputdataOTU$cond=="L"])>mean(inputdataOTU$OTUnum[inputdataOTU$cond=="N"]),"6","2")
    
  }
  
  bootcount <- bootcount+1
  
}
colcount <- colcount+1
}

#Lets plot these to examine how read truncation affects differences
pdf(file="../figures/Preserv_Wilcox_trunc.pdf",width=7,height=7)
plot(Pbootresults$MinReads,Pbootresults$rPreserv18S,type="l",col="darkgreen",ylim=c(-0.1,1),xlab="Number of normalised reads at truncation",ylab="Wilcoxon P Value")
points(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreserv18S)],rep(-0.02,length(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreserv18S)])),pch=as.numeric(Pbootresultsdir$rPreserv18S[!is.na(Pbootresultsdir$rPreserv18S)]),col="darkgreen",cex=0.3)
points(Pbootresults$MinReads,Pbootresults$rPreservCOI,type="l",col="darkblue")
points(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreservCOI)],rep(-0.06,length(Pbootresultsdir$MinReads[!is.na(Pbootresultsdir$rPreservCOI)])),pch=as.numeric(Pbootresultsdir$rPreservCOI[!is.na(Pbootresultsdir$rPreservCOI)]),col="darkblue",cex=0.3)
abline(h=0.05,lty=3,col="red")
legend("topleft",legend=c("18S","COI"),col=c("darkgreen","darkblue"),lty = 1,bty="n")
dev.off()

##Lets make the permanova dataset

PERM18Slong <- rPreserv18S[,substr(names(rPreserv18S),7,7)=="L"]
PERM18Sfroz <- rPreserv18S[,substr(names(rPreserv18S),7,7)=="N"]

test <- rbind(t(PERM18Slong),t(PERM18Sfroz))

treatment <- c(rep("L",12),rep("N",12))
sites <- rep(c(rep("1",3),rep("2",3),rep("3",3),rep("4",3)),2)

PERMresults.18S.P <- adonis(test~treatment*sites,method="bray",perm=999)
PERMresults.18S.S <- adonis(test~sites,method="bray",perm=9999)

#We see highly significant differences between sites and no difference between treatments
##Lets make the permanova dataset

PERMCOIlong <- rPreservCOI[,substr(names(rPreservCOI),7,7)=="L"]
PERMCOIfroz <- rPreservCOI[,substr(names(rPreservCOI),7,7)=="N"]

test <- rbind(t(PERMCOIlong),t(PERMCOIfroz))

treatment <- c(rep("L",12),rep("N",12))
sites <- rep(c(rep("1",3),rep("2",3),rep("3",3),rep("4",3)),2)

PERMresults.COI.P <- adonis(test~treatment*sites,method="bray",perm=999)
PERMresults.COI.S <- adonis(test~sites,method="bray",perm=9999)



#Groups not significantly different 


#### Sediment or Water ####

##Now we have moved on from comparing longmires and frozen lets re-rarefy the COI data without the longmires sampes 
##The limiting sample in the 18S dataset is a longmires sample so no need to rarefy there! 

minimumCOI <- min(colSums(PreservCOI[names(PreservCOI)[-grep("L$",names(PreservCOI))]]))

#Rarefy for no longmires

rPreservCOI<-
  PreservCOI%>%
  filter(rowSums(.)>0)%>%
  t(.)%>%
  rrarefy(.,minimumCOI)%>%
  t(.)
rPreservCOI <- as.data.frame(rPreservCOI,row.names = row.names(PreservCOI))




#18S
#First lets compare sediment and water OTU number! 
palette(c("#CC79A7","#56B4E9","#0072B2","#F0E442","#E69F00", "#00b886","#007857"))

rSedWater18S <- data.frame("HH.W"=rowSums(rPreserv18S[grep("Z.HH[123].N",colnames(rPreserv18S))]),"PQ.W"=rowSums(rPreserv18S[grep("Z.PQ[123].N",colnames(rPreserv18S))]),"PQ.S"=rowSums(rPreserv18S[grep("Z.S.0[123]",colnames(rPreserv18S))]),"TB.W"=rowSums(rPreserv18S[grep("Z.TB[123].N",colnames(rPreserv18S))]),"TB.S"=rowSums(rPreserv18S[grep("Z.S.0[456]",colnames(rPreserv18S))]),"TQ.W"=rowSums(rPreserv18S[grep("Z.TQ[123].N",colnames(rPreserv18S))]),"TQ.S"=rowSums(rPreserv18S[grep("Z.S.0[789]",colnames(rPreserv18S))]))

rSedWater18SOTU <- data.frame("sample"=names(rSedWater18S),"OTUnum"=unname(apply(rSedWater18S,2,counter)))

#Turn names into conds
rSedWater18SOTU$site <- substr(rSedWater18SOTU$sample,1,2)
rSedWater18SOTU$cond <- as.factor(substr(rSedWater18SOTU$sample,4,4))

#Check the overlap of OTUs
overlap18S <- rSedWater18S[-1]
overlap18S[overlap18S>0] <- 1
PQ.18S.overlap <- table(as.factor(overlap18S$PQ.W),as.factor(overlap18S$PQ.S))[2,2]
TQ.18S.overlap <- table(as.factor(overlap18S$TQ.W),as.factor(overlap18S$TQ.S))[2,2]
TB.18S.overlap <- table(as.factor(overlap18S$TB.W),as.factor(overlap18S$TB.S))[2,2]

#now we plot the barplots
pdf(file="../figures/SedWater18S.pdf",width=3,height=6)
linemar<- max(rSedWater18SOTU$OTUnum)/250
barplot(rSedWater18SOTU$OTUnum,names.arg = rSedWater18SOTU$sample,col=1:7,las=2,ylim=c(0,1000),ylab="Number of OTUs")
rect(1.3,PQ.18S.overlap-linemar,3.7,PQ.18S.overlap+linemar,col="white",lty=0,border=FALSE)
rect(3.75,TB.18S.overlap-linemar,6.1,TB.18S.overlap+linemar,col="white",lty=0,border=FALSE)
rect(6.2,TQ.18S.overlap-linemar,9,TQ.18S.overlap+linemar,col="white",lty=0,border=FALSE)
dev.off()

#COI

#First lets compare sediment and water OTU number! 
palette(c("#CC79A7","#56B4E9","#0072B2","#F0E442","#E69F00", "#00b886","#007857"))

rSedWaterCOI <- data.frame("HH.W"=rowSums(rPreservCOI[grep("L.HH[123].N",colnames(rPreservCOI))]),"PQ.W"=rowSums(rPreservCOI[grep("L.PQ[123].N",colnames(rPreservCOI))]),"PQ.S"=rowSums(rPreservCOI[grep("L.S.0[123]",colnames(rPreservCOI))]),"TB.W"=rowSums(rPreservCOI[grep("L.TB[123].N",colnames(rPreservCOI))]),"TB.S"=rowSums(rPreservCOI[grep("L.S.0[456]",colnames(rPreservCOI))]),"TQ.W"=rowSums(rPreservCOI[grep("L.TQ[123].N",colnames(rPreservCOI))]),"TQ.S"=rowSums(rPreservCOI[grep("L.S.0[789]",colnames(rPreservCOI))]))

rSedWaterCOIOTU <- data.frame("sample"=names(rSedWaterCOI),"OTUnum"=unname(apply(rSedWaterCOI,2,counter)))

#Turn names into conds
rSedWaterCOIOTU$site <- substr(rSedWaterCOIOTU$sample,1,2)
rSedWaterCOIOTU$cond <- as.factor(substr(rSedWaterCOIOTU$sample,4,4))

#Check the overlap of OTUs
overlapCOI <- rSedWaterCOI[-1]
overlapCOI[overlapCOI>0] <- 1
PQ.COI.overlap <- table(as.factor(overlapCOI$PQ.W),as.factor(overlapCOI$PQ.S))[2,2]
TQ.COI.overlap <- table(as.factor(overlapCOI$TQ.W),as.factor(overlapCOI$TQ.S))[2,2]
TB.COI.overlap <- table(as.factor(overlapCOI$TB.W),as.factor(overlapCOI$TB.S))[2,2]

#now we plot the barplots
pdf(file="../figures/SedWaterCOI.pdf",width=3,height=6)
linemar<- max(rSedWaterCOIOTU$OTUnum)/250
barplot(rSedWaterCOIOTU$OTUnum,names.arg = rSedWaterCOIOTU$sample,col=1:7,las=2,ylim=c(0,3000),ylab="Number of OTUs")
rect(1.3,PQ.COI.overlap-linemar,3.7,PQ.COI.overlap+linemar,col="white",lty=0,border=FALSE)
rect(3.75,TB.COI.overlap-linemar,6.1,TB.COI.overlap+linemar,col="white",lty=0,border=FALSE)
rect(6.2,TQ.COI.overlap-linemar,9,TQ.COI.overlap+linemar,col="white",lty=0,border=FALSE)
dev.off()

#proportion of unique OTUs
##THIS IS SHAMEFUL CODE
UniqueOTUprop <- cbind(rSedWater18SOTU[,1:2],rSedWaterCOIOTU[,2])[-1,]
UniqueOTUprop$unique18<- rep("NA",6)
UniqueOTUprop$unique18S[1] <- (UniqueOTUprop$OTUnum[1]-PQ.18S.overlap)/UniqueOTUprop$OTUnum[1]
UniqueOTUprop$unique18S[2] <- (UniqueOTUprop$OTUnum[2]-PQ.18S.overlap)/UniqueOTUprop$OTUnum[2]
UniqueOTUprop$unique18S[3] <- (UniqueOTUprop$OTUnum[3]-TB.18S.overlap)/UniqueOTUprop$OTUnum[3]
UniqueOTUprop$unique18S[4] <- (UniqueOTUprop$OTUnum[4]-TB.18S.overlap)/UniqueOTUprop$OTUnum[4]
UniqueOTUprop$unique18S[5] <- (UniqueOTUprop$OTUnum[5]-TQ.18S.overlap)/UniqueOTUprop$OTUnum[5]
UniqueOTUprop$unique18S[6] <- (UniqueOTUprop$OTUnum[6]-TQ.18S.overlap)/UniqueOTUprop$OTUnum[6]
UniqueOTUprop$uniqueCOI<- rep("NA",6)
UniqueOTUprop$uniqueCOI[1] <- (UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[1]-PQ.COI.overlap)/UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[1]
UniqueOTUprop$uniqueCOI[2] <- (UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[2]-PQ.COI.overlap)/UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[2]
UniqueOTUprop$uniqueCOI[3] <- (UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[3]-TB.COI.overlap)/UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[3]
UniqueOTUprop$uniqueCOI[4] <- (UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[4]-TB.COI.overlap)/UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[4]
UniqueOTUprop$uniqueCOI[5] <- (UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[5]-TQ.COI.overlap)/UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[5]
UniqueOTUprop$uniqueCOI[6] <- (UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[6]-TQ.COI.overlap)/UniqueOTUprop$`rSedWaterCOIOTU[, 2]`[6]

mean(c(as.numeric(UniqueOTUprop$uniqueCOI[substr(UniqueOTUprop$sample,4,4)=="S"]),UniqueOTUprop$unique18S[substr(UniqueOTUprop$sample,4,4)=="S"]))

mean(c(as.numeric(UniqueOTUprop$uniqueCOI[substr(UniqueOTUprop$sample,4,4)=="W"]),UniqueOTUprop$unique18S[substr(UniqueOTUprop$sample,4,4)=="W"]))

##Now lets generate a dataset where the reps are not summed
##18S

rSedWater18SOTU_r <- data.frame("sample"=names(rPreserv18S),"OTUnum"=unname(apply(rPreserv18S,2,counter)))
#get rid of leading makrer name
rSedWater18SOTU_r$sample <- rSedWater18SOTU_r$sample %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)}
#annotate sediment samples with their real names
rSedWater18SOTU_r$sample[rSedWater18SOTU_r$sample %in% sedimentID$ID] <- as.character(sedimentID$Code[sedimentID$ID==rSedWater18SOTU_r$sample[rSedWater18SOTU_r$sample %in% sedimentID$ID]])
rSedWater18SOTU_r <-separate(rSedWater18SOTU_r,sample,into=c('site',"cond"))
rSedWater18SOTU_r$rep <- substr(rSedWater18SOTU_r$site,3,3)
rSedWater18SOTU_r$site <- substr(rSedWater18SOTU_r$site,1,2)
rSedWater18SOTU_r$site <- as.factor(rSedWater18SOTU_r$site)
rSedWater18SOTU_r$rep <- as.factor(rSedWater18SOTU_r$rep)
rSedWater18SOTU_r$cond <- as.factor(rSedWater18SOTU_r$cond)
rSedWater18SOTU_r <- rSedWater18SOTU_r[rSedWater18SOTU_r$site!="HH",] 




##COI

rSedWaterCOIOTU_r <- data.frame("sample"=names(rPreservCOI),"OTUnum"=unname(apply(rPreservCOI,2,counter)))
#get rid of leading makrer name
rSedWaterCOIOTU_r$sample <- rSedWaterCOIOTU_r$sample %>%  
{gsub("^[A-Z]*","",.)} %>%
{gsub("^[a-z]*[:.:]","",.)}
#annotate sediment samples with their real names
rSedWaterCOIOTU_r$sample[rSedWaterCOIOTU_r$sample %in% sedimentID$ID] <- as.character(sedimentID$Code[sedimentID$ID==rSedWaterCOIOTU_r$sample[rSedWaterCOIOTU_r$sample %in% sedimentID$ID]])
rSedWaterCOIOTU_r <-separate(rSedWaterCOIOTU_r,sample,into=c('site',"cond"))
rSedWaterCOIOTU_r$rep <- substr(rSedWaterCOIOTU_r$site,3,3)
rSedWaterCOIOTU_r$site <- substr(rSedWaterCOIOTU_r$site,1,2)
rSedWaterCOIOTU_r$site <- as.factor(rSedWaterCOIOTU_r$site)
rSedWaterCOIOTU_r$rep <- as.factor(rSedWaterCOIOTU_r$rep)
rSedWaterCOIOTU_r$cond <- as.factor(rSedWaterCOIOTU_r$cond)
rSedWaterCOIOTU_r <- rSedWaterCOIOTU_r[rSedWaterCOIOTU_r$site!="HH",] 


#Statistics
#18S
##Test for normality under model
aov_residuals <- residuals(object =aov(OTUnum~cond*site,data=rSedWater18SOTU_r[rSedWater18SOTU_r$cond!="L",]))
shapiro.test(x = aov_residuals )
##Test
summary(aov(OTUnum~cond*site,data=rSedWater18SOTU_r[rSedWater18SOTU_r$cond!="L",]))

#COI
##Test for normality under model
aov_residuals <- residuals(object =aov(OTUnum~cond*site,data=rSedWaterCOIOTU_r[rSedWaterCOIOTU_r$cond!="L",]))
shapiro.test(x = aov_residuals )
##Test
summary(aov(OTUnum~cond*site,data=rSedWaterCOIOTU_r[rSedWaterCOIOTU_r$cond!="L",]))




#Now lets visualise the difference in 2d using nMDS

#18S
t18sdat <- t(rPreserv18S[-grep('L$',colnames(rPreserv18S))]) 
MDS18s <- metaMDS(t18sdat,distance = "bray")
nMDSdata18s <-as.data.frame(MDS18s$points)
nMDS18Sstress <- MDS18s$stress


#Here we rename the sediment samples to make life easier
row.names(nMDSdata18s)[7:15] <- paste("Z.",as.character(sedimentID$Code),sep="")
#Now we put in factors to help with plotting 
row.names(nMDSdata18s) <- substr(row.names(nMDSdata18s),3,7)
nMDSdata18s$site <- substr(row.names(nMDSdata18s),1,2)
nMDSdata18s$type <- substr(row.names(nMDSdata18s),5,5)
nMDSdata18s$site.type <- paste(nMDSdata18s$site,nMDSdata18s$type,sep='.')


##The 18S data is ready for visualisation
#Now the COI
tCOIdat <- t(rPreservCOI[-grep('L$',colnames(rPreservCOI))]) 
MDSCOI <- metaMDS(tCOIdat)
nMDSdataCOI <-as.data.frame(MDSCOI$points)
nMDSCOIstress <- MDSCOI$stress

#Here we rename the sediment samples to make life easier
row.names(nMDSdataCOI)[7:15] <- paste("Z.",as.character(sedimentID$Code),sep="")
#Now we put in factors to help with plotting 
row.names(nMDSdataCOI) <- substr(row.names(nMDSdataCOI),3,7)
nMDSdataCOI$site <- substr(row.names(nMDSdataCOI),1,2)
nMDSdataCOI$type <- substr(row.names(nMDSdataCOI),5,5)
nMDSdataCOI$site.type <- paste(nMDSdataCOI$site,nMDSdataCOI$type,sep='.')



##Now lets plot
#Set up a custom palette for colourblind safe plotting
pdf(file="../figures/nMDS18S.pdf",width=6,height=6)
par(mfrow=c(1,1))
palette(c("#CC79A7","#56B4E9","#0072B2","#F0E442","#E69F00", "#00b886","#007857"))
plot(nMDSdata18s$MDS1,nMDSdata18s$MDS2,col=as.factor(nMDSdata18s$site.type),xlab="MDS1",ylab="MDS2",pch=16,cex=2,main="18S all")
text(-1.8,2.6,paste("Stress = ",round(nMDS18Sstress,digits = 3),sep=''))
dev.off()

pdf(file="../figures/nMDSCOI.pdf",width=6,height=6)
par(mfrow=c(1,1))
plot(nMDSdataCOI$MDS1,nMDSdataCOI$MDS2,col=as.factor(nMDSdataCOI$site.type),pch=16,xlab="MDS1",ylab="MDS2",cex=2,main="COI all")
text(-2.1,2.7,paste("Stress = ",round(nMDSCOIstress,digits = 3),sep=''))
dev.off()


barplot(rep(100,11),col=1:11,names.arg = levels(as.factor(nMDSdata18s$site.type)),axes=F)

##Now we have overall data lets look into PERMANOVA stuff
##Lets make the permanova dataset
##18S
PERM18Ssed <- rPreserv18S[,substr(names(rPreserv18S),3,3)=="S"]
PERM18Swater <- rPreserv18S[,substr(names(rPreserv18S),7,7)=="N"]
PERM18Swater <- PERM18Swater[,4:12]

alldat <- rbind(t(PERM18Ssed),t(PERM18Swater))

treatment <- c(rep("S",9),rep("W",9))
sites <- rep(c(rep("1",3),rep("2",3),rep("3",3)),2)

##test for multivariate homogenity of dispersions
anova(betadisper(vegdist(alldat, method="bray"),paste(sites,treatment,sep="_")))
#PERMANOVA
adonis(alldat~treatment+sites,method="bray",perm=999)

##COI
PERMCOIsed <- rPreservCOI[,substr(names(rPreservCOI),3,3)=="S"]
PERMCOIwater <- rPreservCOI[,substr(names(rPreservCOI),7,7)=="N"]
PERMCOIwater <- PERMCOIwater[,4:12]

alldat <- rbind(t(PERMCOIsed),t(PERMCOIwater))

treatment <- c(rep("S",9),rep("W",9))
sites <- rep(c(rep("1",3),rep("2",3),rep("3",3)),2)


##test for multivariate homogenity of dispersions
anova(betadisper(vegdist(alldat, method="bray"),paste(sites,treatment,sep="_")))
#PERMANOVA
adonis(alldat~treatment+sites,method="bray",perm=999)








#now we have some broad details letting us know there are some differenes between sediment and water, lets see which groups are driving this difference
#First we need to annotate the taxonomy and create a dataset with only annotated OTUs


##COI

#first subset the data by observations that have assigned taxonomy
annotatedCOI <- rPreservCOI[rownames(rPreservCOI) %in% strictCOItaxonomy$V1,]
#now put in a column with the assignments
strictCOItaxonomy$assignment <- paste(strictCOItaxonomy$V3,strictCOItaxonomy$V4)
annotatedCOI$assignment <- strictCOItaxonomy$assignment[match(row.names(annotatedCOI),strictCOItaxonomy$V1)]
#now lets clean up the column so it only contains taxonomy tree
annotatedCOI$assignment <- gsub(".*root;(.*)","\\1",annotatedCOI$assignment)
#now lets collapse the data into site-sediment comparisons, excluding HH
treedatCOI <- data.frame("PQ.W"=rowSums(annotatedCOI[7:12]),"PQ.S"=rowSums(annotatedCOI[13:15]),"TB.W"=rowSums(annotatedCOI[22:27]),"TB.S"=rowSums(annotatedCOI[16:18]),"TQ.W"=rowSums(annotatedCOI[28:33]),"TQ.S"=rowSums(annotatedCOI[19:21]),"assignment"=annotatedCOI$assignment)

#Great now lets class each OTU into sediment, water, both or neither catagories per site

treedatCOI$PQ.stat <- ifelse(treedatCOI$PQ.W>0 & treedatCOI$PQ.S>0,"B",ifelse(treedatCOI$PQ.W>0 & treedatCOI$PQ.S==0,"w",ifelse(treedatCOI$PQ.W==0 & treedatCOI$PQ.S>0,"s",ifelse(treedatCOI$PQ.W==0 & treedatCOI$PQ.S==0,"n","error"))))
treedatCOI$TB.stat <- ifelse(treedatCOI$TB.W>0 & treedatCOI$TB.S>0,"B",ifelse(treedatCOI$TB.W>0 & treedatCOI$TB.S==0,"w",ifelse(treedatCOI$TB.W==0 & treedatCOI$TB.S>0,"s",ifelse(treedatCOI$TB.W==0 & treedatCOI$TB.S==0,"n","error"))))
treedatCOI$TQ.stat <- ifelse(treedatCOI$TQ.W>0 & treedatCOI$TQ.S>0,"B",ifelse(treedatCOI$TQ.W>0 & treedatCOI$TQ.S==0,"w",ifelse(treedatCOI$TQ.W==0 & treedatCOI$TQ.S>0,"s",ifelse(treedatCOI$TQ.W==0 & treedatCOI$TQ.S==0,"n","error"))))

treedatCOI$all.stat <- "nonexclusive"

for (number in 1:length(treedatCOI$PQ.W)){

 items <-  unique(c(treedatCOI$PQ.stat[number],treedatCOI$TB.stat[number],treedatCOI$TQ.stat[number]))  
 items <- items[items!='n' ]
 if (length(unique(items))>1){treedatCOI$all.stat[number] <- "nonexclusive"} else {
   if(length(unique(items))<1){treedatCOI$all.stat[number] <- "none"}else{if (unique(items=="w")){treedatCOI$all.stat[number] <- "water"}else{if (unique(items=="s")){treedatCOI$all.stat[number] <- "sediment"}}}}
 
}  
  
  

#18S


#first subset the data by observations that have assigned taxonomy
annotated18S <- rPreserv18S[rownames(rPreserv18S) %in% strict18Staxonomy$V1,]
#now put in a column with the assignments
annotated18S$assignment <- strict18Staxonomy$V2[match(row.names(annotated18S),strict18Staxonomy$V1)]
#now lets clean up the column so it only contains taxonomy tree
annotated18S$assignment <- gsub(".*(Eukaryota.*)","\\1",annotated18S$assignment)
#now lets collapse the data into site-sediment comparisons, excluding HH
treedat18S <- data.frame("PQ.W"=rowSums(annotated18S[7:12]),"PQ.S"=rowSums(annotated18S[13:15]),"TB.W"=rowSums(annotated18S[22:27]),"TB.S"=rowSums(annotated18S[16:18]),"TQ.W"=rowSums(annotated18S[28:33]),"TQ.S"=rowSums(annotated18S[19:21]),"assignment"=annotated18S$assignment)

#Great now lets class each OTU into sediment, water, both or neither catagories per site

treedat18S$PQ.stat <- ifelse(treedat18S$PQ.W>0 & treedat18S$PQ.S>0,"B",ifelse(treedat18S$PQ.W>0 & treedat18S$PQ.S==0,"w",ifelse(treedat18S$PQ.W==0 & treedat18S$PQ.S>0,"s",ifelse(treedat18S$PQ.W==0 & treedat18S$PQ.S==0,"n","error"))))
treedat18S$TB.stat <- ifelse(treedat18S$TB.W>0 & treedat18S$TB.S>0,"B",ifelse(treedat18S$TB.W>0 & treedat18S$TB.S==0,"w",ifelse(treedat18S$TB.W==0 & treedat18S$TB.S>0,"s",ifelse(treedat18S$TB.W==0 & treedat18S$TB.S==0,"n","error"))))
treedat18S$TQ.stat <- ifelse(treedat18S$TQ.W>0 & treedat18S$TQ.S>0,"B",ifelse(treedat18S$TQ.W>0 & treedat18S$TQ.S==0,"w",ifelse(treedat18S$TQ.W==0 & treedat18S$TQ.S>0,"s",ifelse(treedat18S$TQ.W==0 & treedat18S$TQ.S==0,"n","error"))))

treedat18S$all.stat <- "nonexclusive"

for (number in 1:length(treedat18S$PQ.W)){
  
  items <-  unique(c(treedat18S$PQ.stat[number],treedat18S$TB.stat[number],treedat18S$TQ.stat[number]))  
  items <- items[items!='n' ]
  if (length(unique(items))>1){treedat18S$all.stat[number] <- "nonexclusive"} else {
    if(length(unique(items))<1){treedat18S$all.stat[number] <- "none"}else{if (unique(items=="w")){treedat18S$all.stat[number] <- "water"}else{if (unique(items=="s")){treedat18S$all.stat[number] <- "sediment"}}}}
  
}  

table(treedat18S$all.stat)

###Notes - when you redo this analysis on raw data (no taxonomic subsetting) you get greater diversity in sediment for both 18S and COI.

##Output data for WIRMS

WIRMSoutput <- data.frame("ID"=c(rownames(annotated18S),rownames(annotatedCOI)),"dataset"=c(rep("18S",length(rownames(annotated18S))),rep("COI",length(rownames(annotatedCOI)))),"annotation"=c(annotated18S$assignment,annotatedCOI$assignment))

#This expression uses regex to take everything after the last semicolon. It is broken by non alpha numeric characters
WIRMSoutput$species  <- gsub(".*;([A-z0-9 -]*)$","\\1",WIRMSoutput$annotation)

#Some of the entries ae amnbiguous eg. Flabellual sp. so the extra characters breaks the regex. We can seperate these out now and 
#make a clean dataset

WIRMSoutput <- WIRMSoutput[nchar(WIRMSoutput$species)<50,]

write.csv(WIRMSoutput,file="../taxonomy/WORMSdata.csv")

### I then used the WORMS online portal to identify the accepted taxonomy for each of the species. 
#now lets read in the new taxonomy

WORMSdat <- read_excel("../taxonomy/Matches/WORMS.xls")

#get rid of entries with no match
WORMSdat <- WORMSdat[!is.na(WORMSdat$AphiaID),]
WORMSdat18S <- WORMSdat[WORMSdat$dataset=="18S",]
WORMSdatCOI <- WORMSdat[WORMSdat$dataset=="COI",]

##Now lets create data of entries with entire phylogeny

Cleantreedat18s <- treedat18S[rownames(treedat18S) %in% WORMSdat$ID[WORMSdat$dataset=="18S"],]
CleantreedatCOI <- treedatCOI[rownames(treedatCOI) %in% WORMSdat$ID[WORMSdat$dataset=="COI"],]

#18S

taxamediumstats <- Cleantreedat18s[,8:11]

WORMSdat18S<-WORMSdat[WORMSdat$dataset=="18S",]

taxamediumstats$Phylum <- WORMSdat18S$Phylum[match(rownames(taxamediumstats),WORMSdat18S$ID)]
taxamediumstats$Class <- WORMSdat18S$Class[match(rownames(taxamediumstats),WORMSdat18S$ID)]
taxamediumstats$Order <- WORMSdat18S$Order[match(rownames(taxamediumstats),WORMSdat18S$ID)]
taxamediumstats$Family <- WORMSdat18S$Family[match(rownames(taxamediumstats),WORMSdat18S$ID)]
taxamediumstats$Genus <- WORMSdat18S$Genus[match(rownames(taxamediumstats),WORMSdat18S$ID)]
taxamediumstats$Species <- WORMSdat18S$Species[match(rownames(taxamediumstats),WORMSdat18S$ID)]

table(taxamediumstats[,4:5])

taxamediumstats18s<-taxamediumstats

#COI

taxamediumstats <- CleantreedatCOI[,8:11]

WORMSdatCOI<-WORMSdat[WORMSdat$dataset=="COI",]

taxamediumstats$Phylum <- WORMSdatCOI$Phylum[match(rownames(taxamediumstats),WORMSdatCOI$ID)]
taxamediumstats$Class <- WORMSdatCOI$Class[match(rownames(taxamediumstats),WORMSdatCOI$ID)]
taxamediumstats$Order <- WORMSdatCOI$Order[match(rownames(taxamediumstats),WORMSdatCOI$ID)]
taxamediumstats$Family <- WORMSdatCOI$Family[match(rownames(taxamediumstats),WORMSdatCOI$ID)]
taxamediumstats$Genus <- WORMSdatCOI$Genus[match(rownames(taxamediumstats),WORMSdatCOI$ID)]
taxamediumstats$Species <- WORMSdatCOI$Species[match(rownames(taxamediumstats),WORMSdatCOI$ID)]

table(data.frame(cbind(taxamediumstats$all.stat,taxamediumstats$Phylum)))

taxamediumstats <- rbind(taxamediumstats,taxamediumstats18s)


#Now we use some hacky script to get back proportions of each variable, grouping nay taxa with less than 8 entries 

SedWatertaxa <- table(data.frame(cbind(taxamediumstats$all.stat,taxamediumstats$Phylum)))[-1,]

SedWatertaxa <-cbind(SedWatertaxa[,c(1:length(unname(colSums(SedWatertaxa) >5)))[unname(colSums(SedWatertaxa) >8)]],rowSums(SedWatertaxa[,-c(1:length(unname(colSums(SedWatertaxa) >5)))[unname(colSums(SedWatertaxa) >8)]]))

colnames(SedWatertaxa)[11] <- "Other"

SedWatertaxaP <- prop.table(SedWatertaxa,margin=2)

SedWatertaxaP <- rbind(SedWatertaxaP[3,], SedWatertaxaP[1:2,])


row.names(SedWatertaxaP) <- c("Water","Both","Sediment")

##Is detction within each taxa staitically different?

SedWatertaxaStat <-ceiling(rbind((SedWatertaxa[2,]+SedWatertaxa[1,]/2),(SedWatertaxa[3,]+SedWatertaxa[1,]/2)))

landing <- c(rep(NA,length(SedWatertaxaStat[1,])))
for (taxa in 1:length(SedWatertaxaStat[1,])){
  landing[taxa] <- unname((binom.test(SedWatertaxaStat[,taxa],alternative ="two.sided",p=0.5)["p.value"]))
}
p.adjust(unlist(landing),method="bonferroni")


binom.test(SedWatertaxaStat[,10],alternative ="two.sided",p=0.5)

p.adjust()


##Plot
pdf("../figures/SedWatertaxa.pdf",width=10,height=5)
par(mar=c(8.1,6.5,2.1,2.1))
barplot(SedWatertaxaP,col=c("#01665e","#f6e8c3","#8c510a"),las=2)
mtext("Proportion of Taxa Detected in Medium",2,line=3)
dev.off()

data <-data.frame(table(data.frame(cbind(taxamediumstats$all.stat,taxamediumstats$Phylum)))[-1,])

anova(glm(data$Freq~data$X1,family="poisson"))



#####Invasive Species 

invasiondata <- read_xls("../taxonomy/NonNatives/InvasiveSpp.xls")
invasiondata18S <- invasiondata[invasiondata$dataset=="18S",]
invasiondataCOI <- invasiondata[invasiondata$dataset=="COI",]

##We are pulling all the data toghther now to form a table detailing detection of invasive species

##First lets group the replicates per Site/treatment for 18S and COI 

invadersCOI <- rSedWaterCOI[row.names(rSedWaterCOI) %in% WORMSdatCOI$ID[!is.na(WORMSdatCOI$AphiaID)],]
invadersCOI$species <- WORMSdatCOI$species[!is.na(WORMSdatCOI$AphiaID)]

#There are a few duplicates so lets group them NB. we lose data on OTUs here 
invadersCOI<- aggregate(.~species, data=invadersCOI, FUN=sum) 
invadersCOI$status<- rep("N",length(invadersCOI[,1]))

for (row in 1:length(invadersCOI[,1])){
  invadersCOI$status[row] <- invasiondataCOI$`Non-nativeUK`[invasiondataCOI$species==invadersCOI$species[row]][1]
}

invaders18S <- rSedWater18S[row.names(rSedWater18S) %in% WORMSdat18S$ID[!is.na(WORMSdat18S$AphiaID)],]
invaders18S$species <- WORMSdat18S$species[!is.na(WORMSdat18S$AphiaID)]

#There are a few duplicates so lets group them NB. we lose data on OTUs here 
invaders18S<- aggregate(.~species, data=invaders18S, FUN=sum) 
invaders18S$status<- rep("N",length(invaders18S[,1]))

for (row in 1:length(invaders18S[,1])){
  invaders18S$status[row] <- invasiondata18S$`Non-nativeUK`[invasiondata18S$species==invaders18S$species[row]][1]
}


##Excellent - now we have really lovely charts of summed reads per species/site, we need to generate a truncated graphy for plotting 

temp1 <- invaders18S[-9]
temp1$species <- paste(invaders18S$species,invaders18S$status,sep=",")

temp2 <- invadersCOI[-9]
temp2$species <- paste(invadersCOI$species,invadersCOI$status,sep=",")

temp1 <- rbind(temp1,temp2)

invadersBOTH <- aggregate(.~species,data=temp1,FUN=sum)
invadersBOTH.preconcat <- invadersBOTH
invadersBOTH.preconcat <- separate(invadersBOTH.preconcat, species, c("ID","Status"),sep=",")
invadersBOTH.preconcat$Status[invadersBOTH.preconcat$Status=="NA"] <- "IDonly"
invadersBOTH$PQ <- rowSums(cbind(invadersBOTH$PQ.W,invadersBOTH$PQ.S))
invadersBOTH$TQ <- rowSums(cbind(invadersBOTH$TQ.W,invadersBOTH$TQ.S))
invadersBOTH$TB <- rowSums(cbind(invadersBOTH$TB.W,invadersBOTH$TB.S))
invadersBOTH$HH <- invadersBOTH$HH.W
invadersBOTH <- cbind(invadersBOTH[1],invadersBOTH[9:12])

invadersBOTH <- separate(invadersBOTH, species, c("ID","Status"),sep=",")
invadersBOTH$Status[invadersBOTH$Status=="NA"] <- "IDonly"

invadersBOTH[3:6][invadersBOTH[3:6] > 0] <- 1

invadersBOTH <- invadersBOTH[rowSums(invadersBOTH[3:6])>0,]

noInvaders<- aggregate(.~Status, data=invadersBOTH[2:6], FUN=sum) 



pdf(file="../figures/invasionprop.pdf",width=3,height=8)
barplot(as.matrix(noInvaders[2:5]),col=c("#ffffbf","#fc8d59","#d73027"),ylab="Number of Species")
dev.off()

#Mean number of UK invaders per site
mean(colSums(invadersBOTH[invadersBOTH$Status=="yes",3:6]))
sd(colSums(invadersBOTH[invadersBOTH$Status=="yes",3:6]))
#Mean number of global invaders per site
mean(colSums(invadersBOTH[invadersBOTH$Status=="no",3:6]))
sd(colSums(invadersBOTH[invadersBOTH$Status=="no",3:6]))

#Total number of invasev species
length(invadersBOTH$ID[invadersBOTH$Status=="yes"])
length(invadersBOTH$ID[invadersBOTH$Status=="no"])
length(invadersBOTH$ID[invadersBOTH$Status=="IDonly"])

#Now lets add marker and material data to this chart
invadersBOTH$marker <- rep(NA,length(invadersBOTH$ID))
invadersBOTH$medium <- rep(NA,length(invadersBOTH$ID))

for (invasivespecies in 1:length(invadersBOTH$ID)){
  
  #this 'if' ladder annotates the marker 
  if (invadersBOTH$ID[invasivespecies] %in% invaders18S$species & invadersBOTH$ID[invasivespecies] %in% invadersCOI$species ){
     invadersBOTH$marker[invasivespecies] <- "Both"
  }else if (invadersBOTH$ID[invasivespecies] %in% invaders18S$species) {
    invadersBOTH$marker[invasivespecies] <- "18S"
  }else if (invadersBOTH$ID[invasivespecies] %in% invadersCOI$species) {
    invadersBOTH$marker[invasivespecies] <- "COI"
  }else{invadersBOTH$marker[invasivespecies] <- "ERROR"}
  
  #This 'if' ladder annotates the medium
  
  runningW <- sum(invadersBOTH.preconcat$TQ.W[invadersBOTH.preconcat$ID==invadersBOTH$ID[invasivespecies]],invadersBOTH.preconcat$PQ.W[invadersBOTH.preconcat$ID==invadersBOTH$ID[invasivespecies]],invadersBOTH.preconcat$TB.W[invadersBOTH.preconcat$ID==invadersBOTH$ID[invasivespecies]],invadersBOTH.preconcat$HH.W[invadersBOTH.preconcat$ID==invadersBOTH$ID[invasivespecies]])
  runningS <- sum(invadersBOTH.preconcat$TQ.S[invadersBOTH.preconcat$ID==invadersBOTH$ID[invasivespecies]],invadersBOTH.preconcat$PQ.S[invadersBOTH.preconcat$ID==invadersBOTH$ID[invasivespecies]],invadersBOTH.preconcat$TB.S[invadersBOTH.preconcat$ID==invadersBOTH$ID[invasivespecies]])
  if(runningW>0 & runningS>0){
    invadersBOTH$medium[invasivespecies] <- "Both"
  } else if (runningW>0 & runningS==0){
    invadersBOTH$medium[invasivespecies] <- "Water"
  } else if (runningW==0 & runningS>0){
    invadersBOTH$medium[invasivespecies] <- "Sediment"
  }

}

##Lets make some diagrams!

Fig1.4nonnaitves18S <-table(invadersBOTH$Status[invadersBOTH$marker=="18S" | invadersBOTH$marker=="Both"],invadersBOTH$medium[invadersBOTH$marker=="18S" | invadersBOTH$marker=="Both"])
Fig1.4nonnaitvesCOI <-table(invadersBOTH$Status[invadersBOTH$marker=="COI" | invadersBOTH$marker=="Both"],invadersBOTH$medium[invadersBOTH$marker=="COI" | invadersBOTH$marker=="Both"])

Fig1.4nonnaitves18S <- cbind(Fig1.4nonnaitves18S[,"Sediment"],Fig1.4nonnaitves18S[,"Both"],Fig1.4nonnaitves18S[,"Water"])
Fig1.4nonnaitves18S <- rbind(Fig1.4nonnaitves18S["IDonly",],Fig1.4nonnaitves18S["Global",],Fig1.4nonnaitves18S["UK",])

pdf(file="../figures/invasionprop18S.pdf",width=3,height=8)
par(mar=c(8.1,4.1,4.1,2.1))
barplot(Fig1.4nonnaitves18S,las=2,names.arg = c("Sediment",'Both',"Water"),col=c("#ffffbf","#fc8d59","#d73027"))
dev.off()

Fig1.4nonnaitvesCOI <- cbind(Fig1.4nonnaitvesCOI[,"Sediment"],Fig1.4nonnaitvesCOI[,"Both"],Fig1.4nonnaitvesCOI[,"Water"])
Fig1.4nonnaitvesCOI <- rbind(Fig1.4nonnaitvesCOI["IDonly",],Fig1.4nonnaitvesCOI["Global",],Fig1.4nonnaitvesCOI["UK",])

pdf(file="../figures/invasionpropCOI.pdf",width=3,height=8)
par(mar=c(8.1,4.1,4.1,2.1))
barplot(Fig1.4nonnaitvesCOI,las=2,names.arg = c("Sediment",'Both',"Water"),col=c("#ffffbf","#fc8d59","#d73027"))
dev.off()

Fig1.5nonnaitves <-table(invadersBOTH$Status,invadersBOTH$medium)

Fig1.5nonnaitves <- cbind(Fig1.5nonnaitves[,"Sediment"],Fig1.5nonnaitves[,"Both"],Fig1.5nonnaitves[,"Water"])
Fig1.5nonnaitves <- rbind(Fig1.5nonnaitves["IDonly",],Fig1.5nonnaitves["Global",],Fig1.5nonnaitves["UK",])

pdf(file="../figures/invasionpropboth.pdf",width=3,height=8)
par(mar=c(8.1,4.1,4.1,2.1))
barplot(Fig1.5nonnaitves,las=2,names.arg = c("Sediment",'Both',"Water"),col=c("#ffffbf","#fc8d59","#d73027"))
dev.off()





    write.csv(invadersBOTH,file="../output/Invaders.csv")



#### The code basement ####


#This function returns the number of non zero values in an object. The apply statement below runs it across columns
counter <- function(x){
  temp <- x
  temp[temp>0] <- 1
  return(sum(temp))
  rm(temp)
}
apply(samples,2,counter)


#Metacoder Trees

test <- parse_tax_data(treedatCOI, class_cols = "assignment", class_sep = ";")
test

test$data$tax_abund <- calc_taxon_abund(test, "tax_data",
                                        cols = 2:7)

pdf(file="~/Desktop/TB.w.pdf")
heat_tree(test,node_label = taxon_names, node_color =test$data$tax_abund$TB.W, node_size = n_obs,node_size_axis_label = "OTU count",node_color_axis_label = "Samples with reads")
dev.off()
pdf(file="~/Desktop/TB.s.pdf")
heat_tree(test,node_label = taxon_names, node_color =test$data$tax_abund$TB.S, node_size = n_obs,node_size_axis_label = "OTU count",node_color_axis_label = "Samples with reads")
dev.off()


test$data$diff_table <- compare_groups(test, dataset = "tax_abund",
                                       groups = as.factor(rep(c("1","2"),3)),cols=names(treedatCOI)[1:6])
pdf(file="~/Desktop/diff.pdf")
heat_tree(test, 
          node_label = taxon_names,
          node_size = n_obs,
          node_color = log2_median_ratio, 
          node_color_interval = c(-2, 2),
          edge_color_interval = c(-2, 2),
          node_color_range = c("cyan", "gray", "tan"),
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Log 2 ratio of median proportions")
dev.off()



